var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Gogeta","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Gogeta]","category":"page"},{"location":"reference/#Gogeta.SolverParams","page":"Reference","title":"Gogeta.SolverParams","text":"SolverParams\n\nParameters to be used by the solver.\n\nFields\n\nsolver: has to be \"Gurobi\" or \"GLPK\"\nsilent: is the solver log shown\nthreads: use 0 for solver default\nrelax: linear relaxation for the MIP\ntime_limit: time limit for each optimization in the model\n\nExamples\n\njulia> solver_params = SolverParams(solver=\"Gurobi\", silent=true, threads=0, relax=false, time_limit=0);\n\n\n\n\n\n","category":"type"},{"location":"reference/#Gogeta.TEModel","page":"Reference","title":"Gogeta.TEModel","text":"Universal datatype for storing information about a Tree Ensemble Model. This is the datatype that is used when creating the integer optimization problem from a tree ensemble.\n\nDifferent tree models (EvoTrees, XGBoost, RandomForest) require individual conversion functions to this datatype.\n\nFields\n\nn_trees: number of trees in the ensemble\nn_feats: number of features (input variables) in the model\nn_leaves: number of leaves on each tree\nleaves: indices of the leaves on each tree\nsplits: [feature, splitpoint index] pairs accessible by [tree, node]\nsplits_ordered: splitpoints ordered by split value for each feature\nn_splits: number of splitpoints for each feature\npredictions: prediction of each node (zero for nodes that are not leaves)\nsplit_nodes: boolean array containing information whether a node is a split node or not\n\nSplitpoints is the set of unique condition values from the ensemble. Each node is associated with a condition value.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Gogeta.NN_to_MIP-Tuple{Flux.Chain, Vector{Float64}, Vector{Float64}, SolverParams}","page":"Reference","title":"Gogeta.NN_to_MIP","text":"function NN_to_MIP(NN_model::Flux.Chain, init_ub::Vector{Float64}, init_lb::Vector{Float64}, solver_params::SolverParams; tighten_bounds::String=\"fast\", bounds_U=nothing, bounds_L=nothing, out_ub=nothing, out_lb=nothing)\n\nCreates a mixed-integer optimization problem from a ReLU-activated neural network.\n\nReturns a JuMP model containing the MIP formulation as well as the upper and lower activation bounds for each neuron.\n\nThe MIP can be created with initial bounds (optional arguments), or the bounds can be calculated as the model is created in either \"fast\" or \"standard\" mode. If output bounds are to be considered during the tightening, they have to be provided as optional arguments and tighten_bounds must be set to \"output\".\n\nArguments\n\nNN_model: neural network as a Flux.Chain\ninit_ub: upper bounds for the input layer\ninit_lb: lower bounds for the input layer\nsolver_params: parameters for the JuMP model solver\n\nOptional arguments\n\ntighten_bounds: \"fast\", \"standard\" or \"output\"\nbounds_U: upper bounds for the hidden and output layers\nbounds_L: lower bounds for the hidden and output layers\nout_ub: upper bounds for the output layer\nout_lb: lower bounds for the output layer\n\nExamples\n\njulia> nn_jump, U, L = NN_to_MIP(model, init_U, init_L, solver_params; tighten_bounds=\"standard\");\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.TE_to_MIP-Tuple{TEModel, Any, Any}","page":"Reference","title":"Gogeta.TE_to_MIP","text":"function TE_to_MIP(TE::TEModel, optimizer, objective)\n\nCreates a JuMP model opt_model based on the given tree ensemble. Returns opt_model.\n\nThe JuMP model is created without the split constraints.\n\nArguments\n\nTE: A tree ensemble model in the universal data type TEModel. \noptimizer: Optimizer object that will be given to the JuMP model.\nobjective: MINSENSE or MAXSENSE.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.children-Tuple{Int64, Dict, Int64}","page":"Reference","title":"Gogeta.children","text":"function children(id::Int, leaf_dict::Dict, max::Int)\n\nFinds the leaf indices of the children leaves of node id in a binary tree.\n\nReturns an array of the leaf indices.\n\nArguments\n\nid: Index of the node in a binary tree. Indexing starts from one and follows level order.\nleaf_dict: A dictionary (map) of the leaf indices accessible by the node indices.\nmax: Biggest possible node id in the tree. Used to terminate the search.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.compress-Tuple{Flux.Chain, Vector{Float64}, Vector{Float64}}","page":"Reference","title":"Gogeta.compress","text":"function compress(model::Flux.Chain, init_ub::Vector{Float64}, init_lb::Vector{Float64}; params=nothing, bounds_U=nothing, bounds_L=nothing, tighten_bounds=\"fast\")\n\nCreates a new neural network model by identifying stabily active and inactive neurons and removing them.\n\nCan be called with precomputed bounds. Returns the compressed neural network as a Flux.Chain and the indices of the removed neurons in this case.\n\nCan also be called without the bounds to invoke bound tightening (\"standard\" or \"fast\" mode). In this case solver parameters have to be provided. Returns the resulting JuMP model, the compressed neural network, the removed neurons and the computed bounds.\n\nArguments\n\nNN_model: neural network as a Flux.Chain\ninit_ub: upper bounds for the input layer\ninit_lb: lower bounds for the input layer\n\nOptional arguments\n\nparams: parameters for the JuMP model solver\ntighten_bounds: \"fast\" or \"standard\"\nbounds_U: upper bounds for the hidden and output layers\nbounds_L: lower bounds for the hidden and output layers\n\nExamples\n\njulia> jump_model, compressed_model, removed_neurons, bounds_U, bounds_L = compress(model, init_U, init_L; params=solver_params, tighten_bounds=\"standard\");\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.extract_evotrees_info-Tuple{Any}","page":"Reference","title":"Gogeta.extract_evotrees_info","text":"extract_evotrees_info(evo_model; tree_limit=length(evo_model.trees))\n\nGets the data required for constructing the corresponding MIP from an EvoTrees model evo_model.  Returns a custom datatype TEModel which contains the necessary information.\n\nArguments\n\nevo_model: A trained EvoTrees tree ensemble model.\n\nOptional arguments\n\ntree_limit: only first n trees specified by the argument will be used\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.forward_pass!-Tuple{JuMP.Model, Any}","page":"Reference","title":"Gogeta.forward_pass!","text":"function forward_pass!(jump_model::JuMP.Model, input)\n\nCalculates the output of a neural network -representing JuMP model given some input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.get_solution-Tuple{JuMP.Model, TEModel}","page":"Reference","title":"Gogeta.get_solution","text":"function get_solution(model::JuMP.Model, TE::TEModel)\n\nFinds the upper and lower bounds for each input variable given the optimized model.\n\nReturns the bounds for each feature in an array.\n\nArguments\n\nmodel: The optimized JuMP model.\nTE: Struct of type TEModel containing information about the tree ensemble.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.init_TEModel!-Tuple{TEModel}","page":"Reference","title":"Gogeta.init_TEModel!","text":"function init_TEModel!(TE::TEModel)\n\nPrecompute child leaves which are needed for generating the split constraints. Changes child_leaves field of the TEModel.\n\nArguments\n\nTE: Struct of type TEModel containing information about the tree ensemble.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.optimize_with_initial_constraints!-Tuple{JuMP.Model, TEModel}","page":"Reference","title":"Gogeta.optimize_with_initial_constraints!","text":"function optimize_with_initial_constraints!(opt_model::JuMP.Model, TE::TEModel)\n\nAdds all split constraints to the formulation and then solves the MIP.\n\nArguments\n\nopt_model: A JuMP model containing the formulation.\nTE: A tree ensemble model in the universal data type TEModel. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.optimize_with_lazy_constraints!-Tuple{JuMP.Model, TEModel}","page":"Reference","title":"Gogeta.optimize_with_lazy_constraints!","text":"function optimize_with_lazy_constraints!(opt_model::JuMP.Model, TE::TEModel)\n\nSolves the optimization model by utilizing lazy constraints. This means that the split constraints are added one-by-one for each tree.\n\nArguments\n\nopt_model: A JuMP model containing the formulation.\nTE: A tree ensemble model in the universal data type TEModel. \n\n\n\n\n\n","category":"method"},{"location":"#Gogeta.jl","page":"Home","title":"Gogeta.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Gogeta.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Gogeta","category":"page"}]
}
