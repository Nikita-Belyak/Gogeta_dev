var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Gogeta","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Gogeta]","category":"page"},{"location":"reference/#Gogeta.bound_tightening","page":"Reference","title":"Gogeta.bound_tightening","text":"boundtightening(DNN::Chain, initUbounds::Vector{Float32}, initL_bounds::Vector{Float32}, verbose::Bool=false)\n\nA single-threaded implementation of optimal tightened constraint bounds L and U for for a trained DNN. Using these bounds with the createJuMPmodel function reduces solution time for optimization problems.\n\nArguments\n\nDNN::Chain: A trained ReLU DNN.\ninit_U_bounds::Vector{Float32}: Initial upper bounds on the node values of the DNN.\ninit_L_bounds::Vector{Float32}: Initial lower bounds on the node values of the DNN.\nverbose::Bool=false: Controls Gurobi logs.\ntl::Float64=1.0: Controls the time limit for solvign the subproblems \n\nExamples\n\nL_bounds, U_bounds = bound_tightening(DNN, init_U_bounds, init_L_bounds, false, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gogeta.bound_tightening_2workers","page":"Reference","title":"Gogeta.bound_tightening_2workers","text":"boundtightening2workers(DNN::Chain, initUbounds::Vector{Float32}, initLbounds::Vector{Float32}, verbose::Bool=false)\n\nA multi-threaded (using workers) implementation of optimal tightened constraint bounds L and U for for a trained DNN. This function uses two in-place models at each layer to reduce memory usage. A max of 2 workers in use simultaneously. Using these bounds with the createJuMPmodel function reduces solution time for optimization problems.\n\nArguments\n\nDNN::Chain: A trained ReLU DNN.\ninit_U_bounds::Vector{Float32}: Initial upper bounds on the node values of the DNN.\ninit_L_bounds::Vector{Float32}: Initial lower bounds on the node values of the DNN.\nverbose::Bool=false: Controls Gurobi logs.\ntl::Float64=1.0: Controls the time limit for solvign the subproblems.\n\nExamples\n\nL_bounds_workers, U_bounds_workers = bound_tightening_2workers(DNN, init_U_bounds, init_L_bounds, false, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gogeta.bound_tightening_threads","page":"Reference","title":"Gogeta.bound_tightening_threads","text":"boundtighteningthreads(DNN::Chain, initUbounds::Vector{Float32}, initLbounds::Vector{Float32}, verbose::Bool=false, tl::float64=1)\n\nA multi-threaded (using Threads) implementation of optimal tightened constraint bounds L and U for for a trained DNN. Using these bounds with the createJuMPmodel function reduces solution time for optimization problems.\n\nArguments\n\nDNN::Chain: A trained ReLU DNN.\ninit_U_bounds::Vector{Float32}: Initial upper bounds on the node values of the DNN.\ninit_L_bounds::Vector{Float32}: Initial lower bounds on the node values of the DNN.\nverbose::Bool=false: Controls Gurobi logs.\ntl::Float64=1.0: Controls the time limit for solvign the subproblems \n\nExamples\n\nL_bounds_threads, U_bounds_threads = bound_tightening_threads(DNN, init_U_bounds, init_L_bounds, false, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gogeta.bound_tightening_workers","page":"Reference","title":"Gogeta.bound_tightening_workers","text":"boundtighteningworkers(DNN::Chain, initUbounds::Vector{Float32}, initLbounds::Vector{Float32}, verbose::Bool=false, tl::Float64=1.0)\n\nA multi-threaded (using workers) implementation of optimal tightened constraint bounds L and U for for a trained DNN. Using these bounds with the createJuMPmodel function reduces solution time for optimization problems.\n\nArguments\n\nDNN::Chain: A trained ReLU DNN.\ninit_U_bounds::Vector{Float32}: Initial upper bounds on the node values of the DNN.\ninit_L_bounds::Vector{Float32}: Initial lower bounds on the node values of the DNN.\nverbose::Bool=false: Controls Gurobi logs.\ntl::Float64=1.0: Controls the time limit for solvign the subproblems \n\nExamples\n\nL_bounds_workers, U_bounds_workers = bound_tightening_workers(DNN, init_U_bounds, init_L_bounds, false, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gogeta.create_CNN_JuMP_model-Tuple{Flux.Chain, NTuple{4, Int64}, Vector{Array{Float32}}, Vector{Array{Float32}}}","page":"Reference","title":"Gogeta.create_CNN_JuMP_model","text":"createCNNJuMPmodel(CNN::Chain, datashape::Tuple{Int64, Int64, Int64, Int64}, Lbounds::Vector{Array{Float32}}, Ubounds::Vector{Array{Float32}})\n\nConverts a CNN with ReLU activation functions to a 0-1 MILP JuMP model. The ReLU CNN is assumed to be a Flux.Chain. The activation function must be \"relu\" in all hidden (Conv and Dense) layers and \"identity\" in the output layer. The model assumes the following things from the underlying CNN:\n\nInput must be Array{Float32, 4}, (e.g. {32, 32, 3, 1}) where first two indices are height and width of data, \n\nthird index is channel count (e.g. 1 for grayscale image, 3 for RGB), fourth index is batch size (here must be 1)\n\nThe CNN must consist of 3 sections: the convolutional and pooling layers, Flux.flatten, and dense layers.\nConvolutional layers must use relu, pooling layers must be MaxPool or MeanPool. \nLayers must use default setting, such as stride, pad, dilation, etc. Conv.filter, MaxPool.k and MeanPool.k (window) sizes can be arbitrary.\nNo convolutional or pooling layers are necessary before Flux.flatten. Also, no dense layers are necessary after Flux.flatten.\n\nArguments\n\nCNN::Chain: A trained ReLU CNN with the above assumptions\ndata_shape::Tuple{Int64, Int64, Int64, Int64}: Shape of the data used in the CNN as a Tuple, e.g., (32, 32, 3, 1) (similar logis as above)\nL_bounds::Vector{Array{Float32}}: Lower bound big-M values for contraint bounds, indexed L_bounds[layer][channel, height, width]\nU_bounds::Vector{Array{Float32}}: Uower bound big-M values for contraint bounds, indexed U_bounds[layer][channel, height, width]\n\nExamples\n\nmodel = create_CNN_JuMP_model(CNN, data_shape, L_bounds, U_bounds)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.create_JuMP_model","page":"Reference","title":"Gogeta.create_JuMP_model","text":"create_JuMP_model(DNN::Chain, L_bounds::Vector{Float32}, U_bounds::Vector{Float32}, bound_tightening::String=\"none\", bt_verbose::Bool=false)\n\nConverts a ReLU DNN to a 0-1 MILP JuMP model. The ReLU DNN is assumed to be a Flux.Chain. The activation function must be \"relu\" in all hidden layers and \"identity\" in the output layer. The lower and upper bounds to the function are given as a Vector{Float32}. The bounds are in order from the input layer to the output layer. The keyword argument \"bt\" determines if bound tightening is to be used on the constraint bounds: — \"none\": No bound tightening is used. — \"singletread\": One shared JuMP model is used to calculate bounds one at a time. — \"threads\": The bounds are calculated using a separate model for each subproblem using Threads — \"workers\": The bounds are calculated using a separate model for each subproblem using Workers — \"2 workers\": The bounds are calculated with a maximum of two workers at each layer (upper and lower bounds). Each worker reuses the JuMP model.\n\nArguments\n\nDNN::Chain: A trained ReLU DNN.\nL_bounds::Vector{Float32}: Lower bounds on the node values of the DNN.\nU_bounds::Vector{Float32}: Upper bounds on the node values of the DNN.\nbt::String=\"none\": Optional bound tightening of the constraint bounds. Can be set to \"none\", \"singlethread\", \"threads\", \"workers\" or \"2 workers\".\nbt_verbose::Bool=false: Controls Gurobi logs in bound tightening procedures.\n\nExamples\n\nmodel = create_JuMP_model(DNN, L_bounds, U_bounds, \"singlethread\", false)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gogeta.evaluate!-Tuple{JuMP.Model, Vector{Float32}}","page":"Reference","title":"Gogeta.evaluate!","text":"evaluate!(JuMP_model::Model, input::Vector{Float32})\n\nFixes the variables corresponding to the DNN input to a given input vector.\n\nArguments\n\nJuMP_model::Model: A JuMP model representing a traied ReLU DNN (generated using the function createJuMPmodel).\ninput::Vector{Float32}: A given input to the trained DNN.\n\nExamples\n\nevaluate!(JuMP_model, input)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Gogeta.evaluate_CNN!-Tuple{JuMP.Model, Array{Float32, 4}}","page":"Reference","title":"Gogeta.evaluate_CNN!","text":"evaluateCNN!(CNNmodel::Model, input::Array{Float32, 4})\n\nFixes the variables corresponding to the CNN input to a given input array.\n\nArguments\n\nCNN_model::Model: A JuMP model representing a traied ReLU DNN (generated using the function createJuMPmodel).\ninput::Array{Float32, 4}: A given input array to the trained CNN. \n\nExamples\n\nevaluate_CNN!(CNN_model, input)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Gogeta","category":"page"},{"location":"#Gogeta","page":"Home","title":"Gogeta","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Gogeta.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Gogeta","category":"page"}]
}
